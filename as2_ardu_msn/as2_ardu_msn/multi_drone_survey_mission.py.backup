#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy, QoSDurabilityPolicy
from rclpy.executors import MultiThreadedExecutor
import yaml
import numpy as np
import time
import argparse
import sys
import threading
from rclpy.utilities import remove_ros_args

# Direct MAVROS imports
from mavros_msgs.srv import SetMode, CommandBool, CommandTOL
from mavros_msgs.msg import State
from geometry_msgs.msg import PoseStamped
from sensor_msgs.msg import NavSatFix

class DroneController:
    """Individual drone controller class for managing a single drone"""
    
    def __init__(self, node, drone_id, config, waypoints):
        self.node = node
        self.drone_id = drone_id
        self.namespace = f"drone{drone_id}"
        self.config = config
        self.waypoints = waypoints
        
        # State tracking
        self.mavros_state = None
        self.current_position = None
        self.gps_status = None
        self.is_armed = False
        self.is_offboard = False
        
        # Flight parameters
        self.takeoff_altitude = config.get('altitude', 10.0)
        self.flight_speed = config.get('flight_speed', 2.0)
        self.waypoint_tolerance = 1.0
        
        # QoS settings
        self.mavros_qos = QoSProfile(
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=10,
            reliability=QoSReliabilityPolicy.BEST_EFFORT,
            durability=QoSDurabilityPolicy.VOLATILE
        )
        
        self._setup_subscribers()
        self._setup_publishers()
        self._setup_service_clients()
        
    def _setup_subscribers(self):
        """Setup ROS2 subscribers for this drone"""
        self.state_sub = self.node.create_subscription(
            State,
            f'{self.namespace}/mavros/state',
            self.state_callback,
            self.mavros_qos
        )
        
        self.pose_sub = self.node.create_subscription(
            PoseStamped,
            f'{self.namespace}/mavros/local_position/pose',
            self.pose_callback,
            self.mavros_qos
        )
        
        self.gps_sub = self.node.create_subscription(
            NavSatFix,
            f'{self.namespace}/mavros/global_position/global',
            self.gps_callback,
            self.mavros_qos
        )
        
    def _setup_publishers(self):
        """Setup ROS2 publishers for this drone"""
        self.local_pos_pub = self.node.create_publisher(
            PoseStamped,
            f'{self.namespace}/mavros/setpoint_position/local',
            self.mavros_qos
        )
        
    def _setup_service_clients(self):
        """Setup ROS2 service clients for this drone"""
        self.set_mode_client = self.node.create_client(
            SetMode, f'{self.namespace}/mavros/set_mode'
        )
        self.arm_client = self.node.create_client(
            CommandBool, f'{self.namespace}/mavros/cmd/arming'
        )
        self.takeoff_client = self.node.create_client(
            CommandTOL, f'{self.namespace}/mavros/cmd/takeoff'
        )
        self.land_client = self.node.create_client(
            CommandTOL, f'{self.namespace}/mavros/cmd/land'
        )
        
    def state_callback(self, msg):
        """Track MAVROS state changes - only log significant changes"""
        if self.mavros_state is None:
            self.node.get_logger().info(
                f"[{self.namespace}] Initial state - Armed: {msg.armed}, Mode: {msg.mode}"
            )
        elif self.mavros_state.armed != msg.armed or self.mavros_state.mode != msg.mode:
            self.node.get_logger().info(
                f"[{self.namespace}] State change - Armed: {msg.armed}, Mode: {msg.mode}"
            )
        
        self.mavros_state = msg
        self.is_armed = msg.armed
        self.is_offboard = (msg.mode == "OFFBOARD")
        
    def pose_callback(self, msg):
        """Track current position"""
        self.current_position = [
            msg.pose.position.x,
            msg.pose.position.y,
            msg.pose.position.z
        ]
        
    def gps_callback(self, msg):
        """Track GPS status"""
        self.gps_status = msg
        
    def _wait_for_service_result(self, future, timeout_sec=10.0):
        """
        Helper to wait for service call completion WITHOUT using spin_until_future_complete
        This prevents the 'Promise already satisfied' error
        """
        start_time = time.time()
        while not future.done() and (time.time() - start_time) < timeout_sec:
            time.sleep(0.01)  # Small sleep to prevent CPU spinning
        
        if future.done():
            return future.result()
        else:
            return None
        
    def set_guided_mode(self):
        """Set GUIDED mode for ArduPilot - FIXED to avoid future error"""
        if not self.set_mode_client.wait_for_service(timeout_sec=10.0):
            self.node.get_logger().error(f"[{self.namespace}] Set mode service not available")
            return False
        
        req = SetMode.Request()
        req.custom_mode = 'GUIDED'
        
        try:
            future = self.set_mode_client.call_async(req)
            result = self._wait_for_service_result(future, timeout_sec=10.0)
            
            if result and result.mode_sent:
                self.node.get_logger().info(f"[{self.namespace}] GUIDED mode set")
                time.sleep(2)
                return True
            else:
                self.node.get_logger().error(f"[{self.namespace}] Failed to set GUIDED mode")
                return False
        except Exception as e:
            self.node.get_logger().error(f"[{self.namespace}] Error setting mode: {e}")
            return False
            
    def arm_drone(self):
        """Arm the drone - FIXED to avoid future error"""
        self.node.get_logger().info(f"[{self.namespace}] Arming...")
        
        if not self.arm_client.wait_for_service(timeout_sec=15.0):
            self.node.get_logger().error(f"[{self.namespace}] Arming service not available")
            return False
        
        try:
            request = CommandBool.Request()
            request.value = True
            
            future = self.arm_client.call_async(request)
            result = self._wait_for_service_result(future, timeout_sec=15.0)
            
            if result and result.success:
                self.node.get_logger().info(f"[{self.namespace}] Armed successfully")
                time.sleep(1)
                return True
            else:
                self.node.get_logger().error(f"[{self.namespace}] Failed to arm")
                return False
        except Exception as e:
            self.node.get_logger().error(f"[{self.namespace}] Error arming: {e}")
            return False
            
    def takeoff_mavros(self, altitude):
        """Takeoff using MAVROS - FIXED to avoid future error"""
        self.node.get_logger().info(f"[{self.namespace}] Taking off to {altitude}m")
        
        if not self.takeoff_client.wait_for_service(timeout_sec=15.0):
            self.node.get_logger().error(f"[{self.namespace}] Takeoff service not available")
            return False
        
        try:
            request = CommandTOL.Request()
            request.altitude = altitude
            
            future = self.takeoff_client.call_async(request)
            result = self._wait_for_service_result(future, timeout_sec=15.0)
            
            if result and result.success:
                self.node.get_logger().info(f"[{self.namespace}] Takeoff command sent")
                
                # Wait for takeoff completion
                start_time = time.time()
                timeout = 30.0
                target_altitude = altitude * 0.95
                
                while (time.time() - start_time) < timeout:
                    if self.current_position and self.current_position[2] >= target_altitude:
                        self.node.get_logger().info(f"[{self.namespace}] Takeoff completed")
                        return True
                    time.sleep(0.5)
                
                self.node.get_logger().error(f"[{self.namespace}] Takeoff timeout")
                return False
            else:
                self.node.get_logger().error(f"[{self.namespace}] Takeoff command failed")
                return False
                
        except Exception as e:
            self.node.get_logger().error(f"[{self.namespace}] Error during takeoff: {e}")
            return False
            
    def goto_waypoint_mavros(self, waypoint, speed):
        """Navigate to waypoint using MAVROS"""
        self.node.get_logger().info(f"[{self.namespace}] Going to waypoint: {waypoint}")
        
        setpoint = PoseStamped()
        setpoint.header.frame_id = "map"
        setpoint.pose.position.x = waypoint[0]
        setpoint.pose.position.y = waypoint[1]
        setpoint.pose.position.z = waypoint[2]
        setpoint.pose.orientation.w = 1.0
        
        start_time = time.time()
        timeout = 60.0
        last_publish_time = 0
        publish_rate = 0.05
        
        while (time.time() - start_time) < timeout:
            current_time = time.time()
            
            if (current_time - last_publish_time) >= publish_rate:
                setpoint.header.stamp = self.node.get_clock().now().to_msg()
                self.local_pos_pub.publish(setpoint)
                last_publish_time = current_time
            
            if self.current_position:
                distance = np.sqrt(
                    (self.current_position[0] - waypoint[0])**2 +
                    (self.current_position[1] - waypoint[1])**2 +
                    (self.current_position[2] - waypoint[2])**2
                )
                
                if distance < self.waypoint_tolerance:
                    self.node.get_logger().info(f"[{self.namespace}] Reached waypoint")
                    return True
            
            time.sleep(0.01)
        
        self.node.get_logger().error(f"[{self.namespace}] Waypoint navigation timeout")
        return False
        
    def land_mavros(self):
        """Land using MAVROS - FIXED to avoid future error"""
        self.node.get_logger().info(f"[{self.namespace}] Landing...")
        
        if not self.land_client.wait_for_service(timeout_sec=15.0):
            self.node.get_logger().error(f"[{self.namespace}] Land service not available")
            return False
        
        try:
            request = CommandTOL.Request()
            request.altitude = 0.0
            
            future = self.land_client.call_async(request)
            result = self._wait_for_service_result(future, timeout_sec=15.0)
            
            if result and result.success:
                self.node.get_logger().info(f"[{self.namespace}] Land command sent")
                
                start_time = time.time()
                timeout = 30.0
                ground_threshold = 0.2
                
                while (time.time() - start_time) < timeout:
                    if self.current_position and self.current_position[2] <= ground_threshold:
                        self.node.get_logger().info(f"[{self.namespace}] Landing completed")
                        return True
                    time.sleep(0.5)
                
                self.node.get_logger().error(f"[{self.namespace}] Landing timeout")
                return False
            else:
                self.node.get_logger().error(f"[{self.namespace}] Land command failed")
                return False
                
        except Exception as e:
            self.node.get_logger().error(f"[{self.namespace}] Error during landing: {e}")
            return False
            
    def wait_for_ready(self, timeout_sec=45.0):
        """Wait for drone to be ready - callbacks processed by background thread"""
        self.node.get_logger().info(f"[{self.namespace}] Waiting for readiness...")
        
        start_time = time.time()
        last_log_time = start_time
        log_interval = 5.0
        
        while (time.time() - start_time) < timeout_sec:
            current_time = time.time()
            
            # Less frequent logging
            if (current_time - last_log_time) >= log_interval:
                if self.mavros_state is None:
                    self.node.get_logger().info(
                        f"[{self.namespace}] Waiting for MAVROS connection..."
                    )
                elif not self.mavros_state.connected:
                    self.node.get_logger().info(
                        f"[{self.namespace}] MAVROS connecting to FCU..."
                    )
                last_log_time = current_time
            
            # Check if ready (callbacks are processed by background thread)
            if self.mavros_state and self.mavros_state.connected:
                self.node.get_logger().info(
                    f"[{self.namespace}] Ready - Connected to FCU"
                )
                return True
            
            time.sleep(0.1)
        
        self.node.get_logger().error(
            f"[{self.namespace}] Readiness timeout after {timeout_sec}s"
        )
        return False


class MultiDroneSurveyMission(Node):
    def __init__(self, config_file):
        super().__init__('multi_drone_survey_mission')
        
        # Load configuration
        self.get_logger().info(f"Loading config from: {config_file}")
        with open(config_file, 'r') as f:
            full_config = yaml.safe_load(f)
            self.config = full_config['survey_parameters']
            self.swarm_config = full_config.get('swarm_config', {})
        
        # Swarm parameters
        self.num_drones = self.swarm_config.get('num_drones', 3)
        self.formation_type = self.swarm_config.get('formation_type', 'line')
        self.drone_spacing = self.swarm_config.get('drone_spacing', 5.0)
        self.synchronized = self.swarm_config.get('synchronized', True)
        
        # Create drone controllers
        self.drones = {}
        for i in range(self.num_drones):
            waypoints = self.generate_waypoints_for_drone(i)
            self.drones[i] = DroneController(self, i, self.config, waypoints)
            self.get_logger().info(f"Created controller for drone{i} with {len(waypoints)} waypoints")
        
        self.get_logger().info(f"Multi-drone mission initialized with {self.num_drones} drones")
        
    def generate_waypoints_for_drone(self, drone_id):
        """Generate survey waypoints for a specific drone in the swarm"""
        waypoints = []
        width = self.config['area_width']
        length = self.config['area_length']
        altitude = self.config['altitude']
        spacing = self.config['line_spacing']
        origin_x = self.config['origin_offset']['x']
        origin_y = self.config['origin_offset']['y']
        
        # Divide survey area among drones
        if self.formation_type == 'line':
            # Each drone covers a section of the width
            section_width = width / self.num_drones
            start_y = origin_y + (drone_id * section_width)
            end_y = start_y + section_width
            
            num_lines = int(section_width / spacing) + 1
            
            for i in range(num_lines):
                y_pos = start_y + i * spacing
                if y_pos <= end_y:
                    if i % 2 == 0:
                        waypoints.append([origin_x, y_pos, altitude])
                        waypoints.append([origin_x + length, y_pos, altitude])
                    else:
                        waypoints.append([origin_x + length, y_pos, altitude])
                        waypoints.append([origin_x, y_pos, altitude])
                        
        elif self.formation_type == 'parallel':
            # Drones fly in parallel with offset
            num_lines = int(width / spacing) + 1
            
            for i in range(num_lines):
                y_pos = origin_y + i * spacing
                x_offset = drone_id * self.drone_spacing
                
                if i % 2 == 0:
                    waypoints.append([origin_x + x_offset, y_pos, altitude])
                    waypoints.append([origin_x + length + x_offset, y_pos, altitude])
                else:
                    waypoints.append([origin_x + length + x_offset, y_pos, altitude])
                    waypoints.append([origin_x + x_offset, y_pos, altitude])
        
        return waypoints
        
    def execute_drone_mission(self, drone_controller):
        """Execute mission for a single drone"""
        try:
            drone_id = drone_controller.drone_id
            self.get_logger().info(f"Starting mission for drone{drone_id}")
            
            # Wait for readiness
            if not drone_controller.wait_for_ready():
                self.get_logger().error(f"Drone{drone_id} not ready")
                return False
            
            # Set mode and arm
            if not drone_controller.set_guided_mode():
                return False
                
            if not drone_controller.arm_drone():
                return False
            
            # Wait for armed confirmation
            time.sleep(2)
            
            # Takeoff
            if not drone_controller.takeoff_mavros(drone_controller.takeoff_altitude):
                return False
            
            # Execute waypoints
            for i, waypoint in enumerate(drone_controller.waypoints):
                self.get_logger().info(
                    f"Drone{drone_id}: Waypoint {i+1}/{len(drone_controller.waypoints)}: {waypoint}"
                )
                if not drone_controller.goto_waypoint_mavros(waypoint, drone_controller.flight_speed):
                    self.get_logger().error(f"Drone{drone_id}: Failed at waypoint {i+1}")
                    return False
                
                time.sleep(0.5)  # Small delay between waypoints
            
            # Land
            if not drone_controller.land_mavros():
                return False
            
            self.get_logger().info(f"âœ… Drone{drone_id} mission completed successfully!")
            return True
            
        except Exception as e:
            self.get_logger().error(f"Drone{drone_id} mission failed: {e}")
            import traceback
            traceback.print_exc()
            return False
            
    def execute_swarm_mission(self):
        """Execute the swarm survey mission"""
        try:
            self.get_logger().info("ðŸš Starting Multi-Drone Swarm Survey Mission")
            
            if self.synchronized:
                # For now, run synchronized as sequential to avoid threading issues
                self.get_logger().info("Mode: Synchronized flight (running as sequential for stability)")
                
                for drone_id, drone_controller in self.drones.items():
                    success = self.execute_drone_mission(drone_controller)
                    if not success:
                        self.get_logger().error(f"Drone{drone_id} failed, aborting remaining missions")
                        return False
                
                self.get_logger().info("ðŸŽ‰ All drones completed mission successfully!")
                return True
            else:
                # Sequential execution - one drone at a time
                self.get_logger().info("Mode: Sequential flight")
                
                for drone_id, drone_controller in self.drones.items():
                    success = self.execute_drone_mission(drone_controller)
                    if not success:
                        self.get_logger().error(f"Drone{drone_id} failed, aborting remaining missions")
                        return False
                
                self.get_logger().info("ðŸŽ‰ All drones completed mission successfully!")
                return True
                
        except KeyboardInterrupt:
            self.get_logger().info("Mission interrupted by user")
            return False
        except Exception as e:
            self.get_logger().error(f"Swarm mission failed: {e}")
            return False


def main():
    parser = argparse.ArgumentParser(description='Multi-Drone Survey Mission')
    parser.add_argument('--config', type=str, 
                       default='/home/dhandavishal/aerostack2_ws/src/as2_ardu_msn/config/multi_drone_config.yaml',
                       help='Path to configuration file')
    
    args, unknown = parser.parse_known_args(remove_ros_args(sys.argv))
    
    rclpy.init()
    
    mission = None
    exit_code = 0
    
    try:
        # Create mission node
        mission = MultiDroneSurveyMission(args.config)
        
        # Wait a bit for MAVROS connections to establish
        time.sleep(5)
        
        # Execute the mission
        success = mission.execute_swarm_mission()
        
        if success:
            print("ðŸŽ‰ Multi-drone mission completed successfully!")
            exit_code = 0
        else:
            print("âŒ Multi-drone mission failed!")
            exit_code = 1
        
    except KeyboardInterrupt:
        print("\nMission interrupted by user")
        exit_code = 1
    except Exception as e:
        print(f"Mission failed: {e}")
        import traceback
        traceback.print_exc()
        exit_code = 1
    finally:
        # Clean up
        if mission is not None:
            try:
                mission.destroy_node()
            except Exception as e:
                print(f"Cleanup error: {e}")
        
        # Shutdown ROS
        try:
            if rclpy.ok():
                rclpy.shutdown()
        except Exception:
            pass
    
    return exit_code


if __name__ == '__main__':
    exit(main())